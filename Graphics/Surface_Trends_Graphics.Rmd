---
title: "Analysis of Seasonal Water Quality Trends from Friends of Casco Bay Data"
author: "Curtis C. Bohlen, Casco Bay Estuary Partnership"
date: "3/25/2021"
output:
  github_document:
    toc: true
    fig_width: 5
    fig_height: 4
---

<img
    src="https://www.cascobayestuary.org/wp-content/uploads/2014/04/logo_sm.jpg"
    style="position:absolute;top:10px;right:50px;" />

```{r setup, include=FALSE}
knitr::opts_chunk$set(fig.align = 'center',
                      fig.width = 5, fig.height = 4,
                      collapse = TRUE, comment = "#>")
```

# Introduction
This Notebook analyzes FOCB's "Surface" data.
These data are pulled from long term monitoring locations around the Bay.

These are sites visited regularly by FOCB staff, either by boat or on land.  The 
focus is on warm season sampling (April through October), with roughly monthly
samples.  Earlier data from some land-based sites was collected by volunteers.

This notebook builds on other analyses, which looked for overall trends in 
water quality, by looking for "seasonal" trends.  We look for these by  defining
seasonal variables and fitting linear interaction models

We produce an "Early vs Late" factor and a three point factor for for Spring, 
Summer, and Fall, based on the month of sampling.  However, the three season
model is almost always better, so we fully develop analyses only for that
version.

# Load Libraries
```{r load_libraries}
library(tidyverse)
library(readxl)

library(mgcv)     # For `gam()` and `gamm()` models
library(emmeans)
library(grid)     # for lower level plotting functions
library(ggpmisc)  # Allows absolute positioning of annotations and text

library(CBEPgraphics)
load_cbep_fonts()
theme_set(theme_cbep())
```

# Load Data
## Establish Folder Reference
```{r folder_refs}
sibfldnm <- 'Original_Data'
parent   <- dirname(getwd())
sibling  <- file.path(parent,sibfldnm)

dir.create(file.path(getwd(), 'figures'), showWarnings = FALSE)
```

## Primary Data
We specify column names because FOCB data has a row of names, a row of units,
then the data.  This approach is simpler than reading names from the first
row and correcting them to be R syntactic names.
```{r load_data, warning = FALSE}
fn    <- 'FOCB Surface All Current Sites With BSV Data.xlsx'
fpath <- file.path(sibling,fn)

mynames <- c('station', 'dt', 'time', 'sample_depth',
             'secchi', 'water_depth','temperature', 'salinity',
             'do', 'pctsat', 'pH', 'chl', 
             'month', 'year', 'fdom', 'bga', 
             'turbidity', 'blank', 'clouds', 'wndspd',
             'winddir'
             ) 

the_data <- read_excel(fpath, skip=2, col_names = mynames) %>%
  mutate(month = factor(month, levels = 1:12, labels = month.abb)) %>%
  relocate(month, .after = dt)

rm(mynames)
```

### Remove 2020 only data
```{r remove_vars}
the_data <- the_data %>%
select(-c(fdom:winddir))
```

### Add Seasonal Factors
```{r seasonal_f}
the_data <- the_data %>%
  mutate(season_2 = fct_collapse(month, 
                                 Early = c('Apr', 'May', 'Jun'),
                                 Late =  c('Jul', 'Aug', 'Sep', 'Oct')),
         season_3 =  fct_collapse(month, 
                                 Spring = c('Apr', 'May'), 
                                 Summer = c('Jun','Jul', 'Aug'),
                                 Fall   =  c('Sep', 'Oct'))) %>%
  relocate(season_2, season_3, .after = month)
```

### Address Secchi Censored Values
```{r secchi_censored}
the_data <- the_data %>%
  mutate(secchi_2 = if_else(secchi == "BSV", water_depth, as.numeric(secchi)),
         bottom_flag = secchi == "BSV") %>%
  relocate(secchi_2, .after = secchi) %>%
  relocate(bottom_flag, .after = secchi_2)
```

### Limit Chlorophyll to Three Long-Term Stations
```{r limit_chl_long_term}
the_data <- the_data %>%
  mutate(chl = if_else(station %in% c('P5BSD', 'P6FGG', 'P7CBI'),
                                   chl, NA_real_))
```

### Transform the Chlorophyll A Data
We create  log(X + 1) transformed version of the Chlorophyll data.  That allows 
us to conduct analyses of transformed and untransformed data in parallel.

The choice of transform for chlorophyll has significant import, as it determines
whether chlorophyll is considered to have a significant long-term trend or not.
This confusing situation is driven by fifteen  nominal "zero" values in the
data from early in the data record. See 
`Surface_Analysis_Chlorophyll_Trends.Rmd` for details.
```{r transforms_1}
the_data <- the_data %>%
  mutate(log1_chl = log1p(chl)) %>%
  relocate(log1_chl, .after = chl)
```

# Create Trend Data
First, we create a tibble containing information on years in which each
station was sampled.
```{r which_years}
years_data <- the_data %>%
  group_by(station, year) %>%
  summarize(yes = ! all(is.na(temperature)),
            .groups = 'drop_last') %>%
  summarize(years = sum(yes, na.rm = TRUE),
            recent_years =  sum(yes & year > 2014, na.rm = TRUE),
            .groups = 'drop')
```

Then we identify stations with at least 10 years of data, and at least three
years of data from the last five years, and use that list to select data for
trend analysis.  Finally, we adjust the levels in the `station` and 
`station_name` variables.
```{r build_trend_data}
selected_stations <- years_data %>%
  filter(years> 9, recent_years >2) %>%
  pull(station)

trend_data <- the_data %>%
  filter(station %in% selected_stations) %>%
  mutate(station = fct_drop(station)) %>%
  mutate(station = fct_reorder(station, temperature, mean, na.rm = TRUE))
rm(selected_stations, years_data)
```

```{r how_many}
length(unique(trend_data$station))
```

We are reduced to only 17 stations with long-term records for trend analysis.
We noted above that we have limited chlorophyll data before the last couple of 
years.  We address that momentarily

# Construct Nested Tibble
```{r build_nested_data}
units <- tibble(parameter = c('secchi_2', 'temperature', 
                              'salinity', 'do',
                              'pctsat', 'pH', 
                              'chl', 'log1_chl'),
                label = c("Secchi Depth", "Temperature",
                         "Salinity", "Dissolved Oxygen",
                         "Percent Saturation", "pH",
                         "Chlorophyll A", "Log(Chlorophyll A plus 1)"),
                units = c('m', paste0("\U00B0", "C"),
                          'PSU', 'mg/l',
                          '', '',
                          'mg/l', 'mg/l'))

nested_data <- trend_data %>%
  select(-time, -sample_depth, 
         -secchi, -water_depth) %>%
  mutate(year_f = factor(year)) %>%
  relocate(bottom_flag, .after = season_3) %>%
  
  pivot_longer(c(secchi_2:log1_chl), names_to = 'parameter', 
               values_to = 'value') %>%
  filter(! is.na(value)) %>%
  
  # This allows us to ensure the order of the rows in the nested tibble
  mutate(parameter = factor(parameter,
                            levels = c('secchi_2', 'temperature',
                                       'salinity', 'do',
                                       'pctsat', 'pH',
                                       'chl', 'log1_chl'))) %>%

  # change all `bottom_flag` values to FALSE except for secchi_2 df 
  # this allows selective coloring in later graphics
  mutate(bottom_flag = if_else(parameter != 'secchi_2', 
                               NA, 
                               bottom_flag)) %>%
  group_by(parameter) %>%
  nest() %>%
  arrange(parameter) %>%
  left_join(units, by = 'parameter')
```

# Part 1: Modeling
We treat stations as random exemplars of possible stations, and thus rely on
hierarchical models. We use a GAM model with a random factor smoothing term.
We restrict ourselves to linear trends by year.

The month model focus on an overall linear trend, but the deduced 
overall trend is problematic because of different trends by month or season.
The seasonal models unpack those trends.

The seasonal models were motivated by two dimensional tensor smooth GAM models 
developed in "Surface_Analysis_Trends.Rmd".  We look at other interaction models 
in "Surface_Seasonal_Trends.Rmd"

## Models
```{r initial_models}
nested_data <- nested_data %>%
  mutate(lmers = map(data, function(df) gam(value ~ year + month + 
                                              s(station, bs = 're'), 
                                            data = df))) %>%
  mutate(lmer_3_seas_2 = map(data, function(df) gam(value ~ year * season_3 + 
                                              s(station, bs = 're'), 
                                            data = df)))
  names(nested_data$lmers) <- nested_data$parameter
  names(nested_data$lmer_3_seas_2) <- nested_data$parameter
```

###Refit the Chlorophyll Model
We refit the chlorophyll model with an included transformation.
```{r respecify_chlorophyll_model}
dat <- nested_data %>%
  filter(parameter == 'chl') %>%
  pull(data)               # Returns a list
dat <- dat[[1]]  # Extract the first item....  df is now a data frame

#`emmeans` recognizes the log(value + 1) transform, but it does not recognize
# equivalent log1p() transform.  

new_mod_1 <- gam(log(value + 1) ~ year + month + 
                 s(station, bs = 're'), 
               data = dat)
new_mod_2 <- gam(log(value + 1) ~ year * season_3 + 
                 s(station, bs = 're'), 
               data = dat)

nested_data$lmers[nested_data$parameter == 'chl']        <- list(new_mod_1)
nested_data$lmer_3_seas_2[nested_data$parameter == 'chl'] <- list(new_mod_2)
nested_data <- nested_data %>%
  filter(parameter != 'log1_chl')
```

### ANOVAs
#### Month Model
```{r months_anovas}
nested_data <- nested_data %>%
  mutate(anova = map(lmers, function(mod) anova(mod)))
names(nested_data$anova) <- nested_data$parameter

nested_data$anova
```

All models show statistically significant trends EXCEPT dissolved oxygen and pH.

#### Seasonal Interactions Model
```{r seasonal_interaction_anovas}
nested_data <- nested_data %>%
  mutate(anova_3 = map(lmer_3_seas_2, function(mod) anova(mod)))
names(nested_data$anova_3) <- nested_data$parameter

nested_data$anova_3
```
Results are NOT the same.  Salinity now shows no trend, while pH does.

*  Secchi shows no overall trend, but significant differences in seasonal
   trends.  
*  Temperatures shows a significant trend and also a significant interaction
   (a surprise!).  
*  Salinity shows no significant trends or interactions.  
*  DO shows no significant trends or interactions.  
*  Pct Saturation shows a significant trend, but no significant interactions.  
*  pH shows significant trend, with interactions.  
*  Chloride shows significant trend, with interactions.

 
## Compare Slopes
Here, we pull the slopes from both models to guide preparation of
annotation for the graphics....

We want to look to see if separate slopes are significantly different from zero.
That allows us to create appropriate annotations for the different plots.
But note that this "slope" for the chlorophyll model is still on transformed
y values (not `type = `response`).
```{r pull_slopes}
nested_data <- nested_data %>%
  mutate(slope = map(lmers,
                      function(mod) summary(emtrends(mod, 
                                                     ~ 1, 
                                                     var = "year")))) %>%
  mutate(seas_one_slope = map(lmer_3_seas_2,
                      function(mod) summary(emtrends(mod, 
                                                     ~ 1, 
                                                     var = "year")))) %>%
  mutate(seas_three_slopes = map(lmer_3_seas_2,
                      function(mod) summary(emtrends(mod, 
                                                     ~ season_3, 
                                                     var = "year"))))
names(nested_data$slope) <- nested_data$parameter
names(nested_data$seas_one_slope) <- nested_data$parameter
names(nested_data$seas_three_slopes) <- nested_data$parameter
```

```{r display_slopes}
for ( p in nested_data$parameter) {
  row <- nested_data[nested_data$parameter == p,]
  cat('\n\n',p,'\n')
  print(row$slope[[1]])
  print(row$seas_one_slope[[1]])
  print(row$seas_three_slopes[[1]])
}

```
 
We also want to identify which seasons have significant slopes.  We can
figure that out (approximately) by checking if sign of the upper and lower 95%
confidence intervals are the same or not.

```{r trends_by_Season}
which_sig <- function(upper, lower) {
  sig_list <- which(sign(upper) == sign(lower))
  c('Spring', 'Summer', 'Fall')[sig_list]
}


test <- nested_data$seas_three_slopes[[3]] 
which_sig(test$upper.CL, test$lower.CL)
```

```{r display_trends_by_season}
nested_data <- nested_data %>%
  mutate(seas_change = map(seas_three_slopes,
                      function(df) which_sig(df$upper.CL, df$lower.CL)))
names(nested_data$seas_change) <- nested_data$parameter
nested_data$seas_change
```
 
# Deriving Annotations from general results.
## Terminology:
Use of "Decrease" and "Increase" are consistent, but potentially confusing.  We
want to add signals for "improving" or "worsening" conditions, which sometimes 
correspond to increasing and sometimes decreasing values.

## Notes
We want to say the following:
*  Secchi:  Show seasonal data and highlight seasonal trend, with declining
   water quality in summer and fall, but little change in spring.
   *  "Decrease Summer and Fall"
*  Temperatures:  Highlight overall trend.  Interaction is significant, but
   small.
   *  "Increasing ~ 0.56 degrees C per decade"
*  Salinity: Emphasize uncertainty.  Possible weak trend.
   *  "Possible summer decrease"
*  DO:  No significant terms by ANOVA, so don't want to interpret marginal means
   *  "No trend"
*  Pct Saturation: Highlight overall trend
   *  "Increase in spring and fall"
*  pH:  Highlight different seasonal patterns that cancel each other out.
   *  "Spring increase, summer decrease"
*  Chlorophyll:  Overall trend, but strong seasonal differences
   *  "Decrease in spring and summer"

### Marginal Means
These means are all marginal to the identity of the stations.  It's worth noting
that differences in slope that jump out in these graphics often vanish into
relative insignificance when plotted against the source data.  Also, some 
"statistically significant" differences in seasonal slopes are pretty small, on
pretty small slopes, and thus are probably not worth interpreting.
```{r build_interaction_plots}
nested_data <- nested_data %>%
  mutate(emmi_3 = map(lmer_3_seas_2, function(mod) emmip(mod, season_3 ~ year, 
                                                        at = list(year = 1993:2020),
                                                       plotit = FALSE)))
```


# Graphics
## Primary Plots
We could construct this as a function, but the for loop is a bit faster to
develop.
```{r make_plots, fig.width = 4, fig.height = 3.5}
plts <- list()
for (p in nested_data$parameter) {
  row <- nested_data[nested_data$parameter == p,]
  dat <- row$data[[1]]
  preds <- row$emmi_3[[1]]
  label <- row$label
  units <- row$units
  
  preds <-  preds %>%
    mutate(UCL = yvar + 1.96 * SE,
           LCL = yvar - 1.96 * SE)
  
  plt <-    ggplot() +
    geom_jitter(mapping = aes(year, value, color = season_3), data = dat, 
                alpha = 0.1, width = 0.25) +
    
    geom_line(mapping = aes(x = xvar, y = yvar, color = tvar), data = preds,
              size = 1) +
    #geom_ribbon(aes(x = xvar, ymin = LCL, ymax = UCL, fill = tvar), data = preds,
    #            color = NA, alpha = 0.15) +
    
    guides(fill = 'none') +
    scale_color_manual(values = cbep_colors2()[c(1,2,4)],
                       name = '',
                guide = guide_legend(override.aes = list(alpha = 1))) +
    scale_fill_manual(values = cbep_colors2()[c(1,2,4)]) +
    
    theme_cbep(base_size = 14) +
    theme(legend.position = 'bottom',
          axis.title.y = element_text(size = 12),
          #axis.line = element_line(color = 'gray85')
          ) +

    ylab(paste0(label, 
                if_else(nchar(units) > 0, ' (',''),
                units,
                if_else(nchar(units) > 0, ')',''))) +
    xlab('') +
    labs(color = '')
 plts[p] <- list(plt)
  print(plt)
}
nested_data$plt <- plts
```

## Fix Chlorophyll Models and Graphic
We need to plot the chlorophyll data on a transformed axis, which takes several
steps.

1.  Extract marginal trends from the revised model with `type == "response"`  
2.  Redraw the plot, with an added transformation on the Y axis, while
    controlling the locations of the breaks.

`emmeans` recognizes the log(value + 1) transform, but it does not recognize the 
equivalent log1p() transform.  
```{r refit_chl_models}

mod<- nested_data[nested_data$parameter == 'chl',]$lmer_3_seas_2[[1]]
pred <- emmip(mod, season_3 ~ year, 
             at = list(year = 1993:2020), type = 'response',
             plotit = FALSE) %>%
  filter(year > 2000)

nested_data$emmi_3[nested_data$parameter == 'chl'] <- list(pred)
```

#### Updated Chlorophyll Plot  
The primary change in the code here is addition of 
`scale_y_continuous(trans = 'log1p')`.  Unlike emmeans, ggplot recognizes the 
transform.  We also have to explicitly control the x axis to match the other
plots.
```{r fix_chl_plot, fig.width = 4, fig.height = 3.5}
row <- nested_data[nested_data$parameter == 'chl',]
  dat <- row$data[[1]]
  preds <- row$emmi_3[[1]]
  label <- row$label
  units <- row$units
  
  preds <-  preds %>%
    mutate(UCL = yvar + 1.96 * SE,
           LCL = yvar - 1.96 * SE)
  
  plt <-  ggplot() +
    geom_jitter(mapping = aes(year, value, color = season_3), data = dat, 
                alpha = 0.1, width = 0.25) +
    
    geom_line(mapping = aes(x = xvar, y = yvar, color = tvar), data = preds,
              size = 1) +
    #geom_ribbon(aes(x = xvar, ymin = LCL, ymax = UCL, fill = tvar), data = preds,
    #            color = NA, alpha = 0.15) +
    
    guides(fill = 'none') +
    scale_color_manual(values = cbep_colors2()[c(1,2,4)],
                       name = '',
                guide = guide_legend(override.aes = list(alpha = 1))) +
    scale_fill_manual(values = cbep_colors2()[c(1,2,4)]) +
    
    theme_cbep(base_size = 14) +
    theme(legend.position = 'bottom',
          axis.title.y = element_text(size = 12),
          axis.line = element_line(color = 'gray85')) +

    ylab(paste0(label, 
                if_else(nchar(units) > 0, ' (',''),
                units,
                if_else(nchar(units) > 0, ')',''))) +
    xlab('') +
    labs(color = '') +
    xlim(1993, 2020) +
    scale_y_continuous(trans = 'log1p', breaks = c(0,1,  5, 10, 50, 100, 200))
  print(plt)
  nested_data$plt[nested_data$parameter == 'chl'] <- list(plt)
```

# Add Annotations
After some experimentation, we decided to place annotations and Symbols with 
functions included in the `ggpmisc` package, specifically, the 
`geom_text_npc()` function, and an overridden version of `annotate()` that
allows absolute coordinates rather than data coordinates.  This makes the
placement of annotations in a series of similar graphics a bit more straight 
forward.

## Define Annotations
```{r define_annot}
annotations <- c("Decrease Summer and Fall",
                 "Increasing ~ 0.56 degrees C\nper decade",
                 "Possible summer decrease",
                 "No trend",
                 "Increase in spring and fall",
                 "Spring increase, summer decrease",
                 "Decrease in spring and summer")
nested_data$annot <- annotations
```

## Annotation Placement
Most annotations can go in upper right corner.  We start with that, then modify
as needed.
```{r place_annot}
ann_xloc <- rep('left', length(nested_data$parameter))
ann_yloc <- rep('bottom', length(nested_data$parameter))

ann_xloc[1] <- 'right'    # Secchi
ann_yloc[1] <- 'top'    # Secchi
ann_xloc[2] <- 'right'  # temperature
ann_xloc[7] <- 'right'  # Chlorophyll

nested_data$ann_x_loc <- ann_xloc
nested_data$ann_y_loc <- ann_yloc
```

## Demo: Add Annotations to Plots
```{r demo_annot, fig.width = 4, fig.height = 3.5}
for (p in nested_data$parameter) {
  row <- nested_data[nested_data$parameter == p,]
  print(row$plt[[1]] +
        annotate('text_npc', npcx = row$ann_x_loc, npcy = row$ann_y_loc, 
                 label = row$annot,
                 hjust = 'inward',
                 size = 3.5))

}

```



# Symbols
In the upper left, we want to offer symbols to signal improving or worsening
.conditions.  Here we search for some suitable unicode glyphs.


Could use "troubling" and "hopeful" to describe trends...
```{r symbol_words}
symbols = 
c('worse',
  'worse',
  'steady',
  'steady',
  'better',
  'steady',
  'better')
nested_data$symbols <- factor(symbols, levels = c('worse', 'steady', 'better'))
```


The challenge we face is that we are already using a color scale for or core
symbols.  what we want to do here is place a glyph without using a 
color scale.

We can consider either unicode arrow glyph or simple triangle shapes as the "up" 
and "down" symbols for things getting better or things getting worse.  

## Possible Unicode Glyphs
### Hollow Shapes
```{r hollow}
cat('\U1403')
cat('\U25A1')
cat('\U25AD')
cat('\U1401')
```
### Solid Shapes
```{r solid}
cat('\U25bc')
cat('\U25ac')
cat('\U25b2')
cat('\U25fc')
cat('\n')
```
```{r define_glyphs}
myglyphs <- factor(c('\U25bc', '\U25ac','\U25b2'),
                   levels = c('\U25bc', '\U25ac','\U25b2'))
```

### Heavy Arrows
Unfortunately, the following nice arrows show in RStudio, but do not 
plot properly in cairo's pdf engine (at least with the default font).  
```{r arrows}
cat('\U1f81f')
cat('\U2261')
cat('\U1f81d')
```
```{r define_alt_glyphs}
altglyphs <- factor(c('\U1f81f', '\U2261','\U1f81d'),
                   levels = c('\U1f81f', '\U2261','\U1f81d'))
```

### Alternate "No Change" Glyphs
```{r no_change}
cat('\U2248')
cat('\U2194')
```

## Demo Glyphs
Although the horizontal bar does not plot correctly here, it does, below.
```{r demo_myglyphs, fig.width = 3, fig.height = .75}
shapes <- tibble(x = 1:3, y = 1,
                 glyph = myglyphs) 
ggplot(shapes, aes(x,y)) +
  geom_text(aes(label = glyph, color = glyph), size = 12) +
  scale_color_manual(values = c('red' , 'gray', 'green')) +
  guides(color = 'none') +
  theme_void()
```

```{r demo_altglyphs, fig.width = 3, fig.height = .75}
shapes <- tibble(x = 1:3, y = 1,
                 glyph = altglyphs) 
ggplot(shapes, aes(x,y)) +
  geom_text(aes(label = glyph, color = glyph), size = 12) +
  scale_color_manual(values = c('red' , 'gray', 'green')) +
  guides(color = 'none') +
  theme_void()
```

Unfortunately, those glyphs don't plot  with the cairo_pdf engine.  It may be 
that the font does not include those glyphs, or that cairo can not handle those
unicode values.

## Demo Add Glyphs to Plots
```{r demo_symbols, fig.width = 3.5, fig.height = 3.25}
for (p in nested_data$parameter) {
  row <- nested_data[nested_data$parameter == p,]
  print(row$plt[[1]] +
          if(row$symbols == 'better') {
            annotate('text_npc', npcx = 'left', npcy = 'top',
                     label = myglyphs[3], color = 'green2',
                     size = 7)
          }
        else if(row$symbols == 'worse'){
          annotate('text_npc', npcx = 'left', npcy = 'top',
                   label = myglyphs[1], color = 'red4',
                   size = 7)
        }
        else {
          annotate('text_npc', npcx = 'left', npcy = 'top',
                   label = myglyphs[2], color = 'gray50',
                   size = 7)          
        }
  )
  
}

```



# Add Both
```{r final_graphics, fig.width = 3.5, fig.height = 3.25}
for (p in nested_data$parameter) {
  row <- nested_data[nested_data$parameter == p,]
  print(row$plt[[1]] +
          annotate('text_npc', npcx = row$ann_x_loc, npcy = row$ann_y_loc, 
                 label = row$annot, family = 'Montserrat',
                 size = 3) +
    
        if(row$symbols == 'better') {
            annotate('text_npc', npcx = 'left', npcy = 'top',
                     label = myglyphs[3], color = 'green2',
                     size = 7)
          }
        else if(row$symbols == 'worse'){
          annotate('text_npc', npcx = 'left', npcy = 'top',
                   label = myglyphs[1], color = 'red4',
                   size = 7)
        }
        else {
          annotate('text_npc', npcx = 'left', npcy = 'top',
                   label = myglyphs[2], color = 'gray50',
                   size = 7)          
        }
  )
  fn <- paste0('focb_s_trend_', p, '.pdf')
  fp <- file.path('figures', fn)
  ggsave(fp, device = cairo_pdf, width = 3.5, height = 3.25)


}

```